<!DOCTYPE html>
<html>
  <head>
    <link rel="stylesheet" href="style.css">
    <link rel="icon" href="circularIcon.png">
    <meta charset="utf-8">
    <meta name="viewport" content='width="device-width", initial-scale="1.0"'>
    <title>Sorting Algorithms!!!!</title>
  </head>
  <body>
      <nav id="navbar">
        <header id="nav-header">Sorting algorithms</header>
        <ul>
          <a class="nav-link" href="#5_sorting_algorithms"><li class="nav-link">5 sorting algorithms</li></a>
          <a class="nav-link" href="#bubble_sort"><li>Bubble sort</li></a>
          <a class="nav-link" href="#radix_sort"><li>Radix sort</li></a>
          <a class="nav-link" href="#introsort"><li>Counting Sort</li></a>
          <a class="nav-link" href="#merge_sort"><li>Merge sort</li></a>
          <a class="nav-link" href="#quicksort"><li>Quicksort</li></a>
        </ul>
      </nav>
    
    <main id="main-doc">
      

      <section id="5_sorting_algorithms" class="main-section">
        <header>
          <h1>5 sorting algorithms</h1>
        </header>
        <p>In this article we are gonna explore some
          sorting algorithm, going through the best 
          to the most infamous</p>
      </section>
      
      <!--1er Titulo-->
      <section id="bubble_sort" class="main-section">
        <header>
          <h1>Bubble sort</h1>
        </header>
        <p>
          Bubble sort, sometimes referred to as sinking sort, is a simple sorting algorithm that repeatedly steps through the input list element by element, comparing the current element with the one after it, swapping their values if needed. These passes through the list are repeated until no swaps have to be performed during a pass, meaning that the list has become fully sorted. The algorithm, which is a comparison sort, is named for the way the larger elements "bubble" up to the top of the list.Known for its simplicity, the Bubble algorythm
        </p>
        <h3>Bubble sort pseudocode</h3>
        <pre class="code">
procedure bubbleSort(A : list of sortable items)
n := length(A)
repeat
    swapped := false
    for i := 1 to n-1 inclusive do
        { if this pair is out of order }
        if A[i-1] > A[i] then
            { swap them and remember something changed }
            swap(A[i-1], A[i])
            swapped := true
        end if
    end for
  until not swapped
end procedure</pre>
          <h3>Bubble sort visual representation</h3>

        <iframe width="560" height="315" src="https://www.youtube.com/embed/Cq7SMsQBEUw?si=yohPL17sMbi1vrxa" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
        <p>Most of the information was taken from <a href="https://en.wikipedia.org/wiki/Bubble_sort">here</a></p>
      </section>
      <!--2do Titulo-->
      <section id="quicksort" class="main-section">
        <header>
          <h1>Quicksort</h1>
        </header>
        <p>
          Quicksort is an efficient, general-purpose sorting algorithm. Quicksort was developed by British computer scientist Tony Hoare in 1959 and published in 1961. It is still a commonly used algorithm for sorting. Overall, it is slightly faster than merge sort and heapsort for randomized data, particularly on larger distributions.        </p>
        <h3>Quicksort pseudocode</h3>
        <pre class="code">
// Sorts a (portion of an) array, divides it into partitions, then sorts those
algorithm quicksort(A, lo, hi) is 
  // Ensure indices are in correct order
  if lo >= hi || lo < 0 then 
    return
              
  // Partition array and get the pivot index
  p := partition(A, lo, hi) 
                
  // Sort the two partitions
  quicksort(A, lo, p - 1) // Left side of pivot
  quicksort(A, p + 1, hi) // Right side of pivot
          
// Divides array into two partitions
algorithm partition(A, lo, hi) is 
  pivot := A[hi] // Choose the last element as the pivot
          
  // Temporary pivot index
  i := lo
          
  for j := lo to hi - 1 do 
    // If the current element is less than or equal to the pivot
    if A[j] <= pivot then 
      // Swap the current element with the element at the temporary pivot index
      swap A[i] with A[j]
      // Move the temporary pivot index forward
      i := i + 1
          
  // Swap the pivot with the last element
  swap A[i] with A[hi]
  return i // the pivot index</pre>
          <h3>Quicksort visual representation</h3>

        <iframe width="560" height="315" src="https://www.youtube.com/embed/9IqV6ZSjuaI?si=LqFW27b6YvD1yIqb" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
        <p>Most of the information was taken from <a href="https://en.wikipedia.org/wiki/Quicksort">here</a></p>
      </section>
      <!--3er Titulo-->
      <section id="merge-sort" class="main-section">
        <header>
          <h1>Merge sort</h1>
        </header>
        <p>
          Merge sort (also commonly spelled as mergesort and as merge-sort) is an efficient, general-purpose, and comparison-based sorting algorithm. Most implementations produce a stable sort, which means that the relative order of equal elements is the same in the input and output. Merge sort is a divide-and-conquer algorithm that was invented by John von Neumann in 1945. A detailed description and analysis of bottom-up merge sort appeared in a report by Goldstine and von Neumann as early as 1948.
        </p>
        <h3>Merge sort pseudocode</h3>
        <pre class="code">
 function merge_sort(list m) is
// Base case. A list of zero or one elements is sorted, by definition.
if length of m ≤ 1 then
    return m
      
// Recursive case. First, divide the list into equal-sized sublists
// consisting of the first half and second half of the list.
// This assumes lists start at index 0.
var left := empty list
var right := empty list
for each x with index i in m do
    if i < (length of m)/2 then
        add x to left
    else
        add x to right
      
// Recursively sort both sublists.
left := merge_sort(left)
right := merge_sort(right)
      
// Then merge the now-sorted sublists.
return merge(left, right)</pre>
          <h3>Merge sort visual representation</h3>
        <iframe width="560" height="315" src="https://www.youtube.com/embed/ZRPoEKHXTJg?si=ncTTQMdkiXyJZZD1" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
        <p>Most of the information was taken from <a href="https://en.wikipedia.org/wiki/Merge_sort">here</a></p>
      </section>
      
      <!--4to Titulo-->
      <section id="introsort" class="main-section">
        <header>
          <h1>Introsort sort</h1>
        </header>
        <p>
          Introsort or introspective sort is a hybrid sorting algorithm that provides both fast average performance and (asymptotically) optimal worst-case performance. It begins with quicksort, it switches to heapsort when the recursion depth exceeds a level based on (the logarithm of) the number of elements being sorted and it switches to insertion sort when the number of elements is below some threshold. This combines the good parts of the three algorithms, with practical performance comparable to quicksort on typical data sets and worst-case O(n log n) runtime due to the heap sort. Since the three algorithms it uses are comparison sorts, it is also a comparison sort.
        </p>
        <h3>Introsort pseudocode</h3>
        <pre class="code">
procedure sort(A : array):
    maxdepth ← ⌊log2(length(A))⌋ × 2
    introsort(A, maxdepth)

procedure introsort(A, maxdepth):
    n ← length(A)
    if n < 16:
        insertionsort(A)
    else if maxdepth = 0:
        heapsort(A)
    else:
        p ← partition(A)  
        // assume this function does pivot selection, 
        // p is the final position of the pivot
        introsort(A[1:p-1], maxdepth - 1)
        introsort(A[p+1:n], maxdepth - 1)</pre>
          <h3>Introsort visual representation</h3>

        <iframe width="560" height="315" src="https://www.youtube.com/embed/67ta5WTjjUo?si=Sh-YDVDVgE_IjN1Q" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
        <p>Most of the information was taken from <a href="https://en.wikipedia.org/wiki/Introsort">here</a></p>
      </section>
      <div></div>

      
      <!--Block Sort-->
      <section id="block-sort" class="main-section">
        <header>
          <h1>Block sort</h1>
        </header>
        <p>
          Block sort, or block merge sort, is a sorting algorithm combining at least two merge operations with an insertion sort to arrive at O(n log n) (see Big O notation) in-place stable sorting time. It gets its name from the observation that merging two sorted lists, A and B, is equivalent to breaking A into evenly sized blocks, inserting each A block into B under special rules, and merging AB pairs.
        </p>
        <h3>Pseudocode</h3>
        <pre class="code"># Python Implementation
def block_sort(arr, block_size):
          
  # Create an empty list to
  # hold the sorted blocks
  blocks = []
          
  # Divide the input array into
# blocks of size block_size
          
  for i in range(0, len(arr), block_size):
          
    block = arr[i:i + block_size]
          
    # Sort each block and append
    # it to the list of sorted blocks
    blocks.append(sorted(block))
          
  # Merge the sorted blocks into
  # a single sorted list
  result = []
  while blocks:
          
    # Find the smallest element in
    # the first block of
    # each sorted block
    min_idx = 0
    for i in range(1, len(blocks)):
      if blocks[i][0] < blocks[min_idx][0]:
        min_idx = i
          
    # Remove the smallest element and
    # append it to the result list
    result.append(blocks[min_idx].pop(0))
          
    # If the block is now empty, remove
    # it from the list of sorted blocks
    if len(blocks[min_idx]) == 0:
      blocks.pop(min_idx)
  return result
          
          
# Original arr
arr = [1, 7, 8, 2, 3, 5, 4, 6]
print('Input: ', arr)
          
# Select box size
block_size = 3
          
# Function call
print('Output:', block_sort(arr, block_size))</pre>
          <h3>Visual representation</h3>
        <iframe width="560" height="315" src="https://www.youtube.com/embed/NjcSyD7p660?si=3mLjbCDESdGVxV9_" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
        <p>Most of the information was taken from <a href="https://en.wikipedia.org/wiki/Block_sort">here</a> and <a href="https://www.geeksforgeeks.org/radix-sort/">here</a>.</p>
      </section>

      <!-- RADIX SORT -->
      <section id="radix-sort" class="main-section">
        <header>
          <h1>Radix sort</h1>
        </header>
        <p>
          Radix sort is a non-comparative sorting algorithm. It avoids comparison by creating and distributing elements into buckets according to their radix. For elements with more than one significant digit, this bucketing process is repeated for each digit, while preserving the ordering of the prior step, until all digits have been considered. For this reason, radix sort has also been called bucket sort and digital sort.
        </p>
        <h3>Pseudocode</h3>
        <pre class="code">
// C++ implementation of Radix Sort

#include &lt;iostream&gt;
using namespace std;
          
// A utility function to get maximum
// value in arr[]
int getMax(int arr[], int n)
{
    int mx = arr[0];
    for (int i = 1; i < n; i++)
        if (arr[i] > mx)
            mx = arr[i];
    return mx;
}
          
// A function to do counting sort of arr[]
// according to the digit
// represented by exp.
void countSort(int arr[], int n, int exp)
{
          
    // Output array
    int output[n];
    int i, count[10] = { 0 };
          
    // Store count of occurrences
    // in count[]
    for (i = 0; i < n; i++)
        count[(arr[i] / exp) % 10]++;
          
    // Change count[i] so that count[i]
    // now contains actual position
    // of this digit in output[]
    for (i = 1; i < 10; i++)
        count[i] += count[i - 1];
          
    // Build the output array
    for (i = n - 1; i >= 0; i--) {
        output[count[(arr[i] / exp) % 10] - 1] = arr[i];
        count[(arr[i] / exp) % 10]--;
    }
          
    // Copy the output array to arr[],
    // so that arr[] now contains sorted
    // numbers according to current digit
    for (i = 0; i < n; i++)
        arr[i] = output[i];
}
          
// The main function to that sorts arr[]
// of size n using Radix Sort
void radixsort(int arr[], int n)
{
          
    // Find the maximum number to
    // know number of digits
    int m = getMax(arr, n);
          
    // Do counting sort for every digit.
    // Note that instead of passing digit
    // number, exp is passed. exp is 10^i
    // where i is current digit number
    for (int exp = 1; m / exp > 0; exp *= 10)
        countSort(arr, n, exp);
}
          
// A utility function to print an array
void print(int arr[], int n)
{
    for (int i = 0; i < n; i++)
        cout << arr[i] << " ";
}
          
// Driver Code
int main()
{
    int arr[] = { 170, 45, 75, 90, 802, 24, 2, 66 };
    int n = sizeof(arr) / sizeof(arr[0]);
          
    // Function Call
    radixsort(arr, n);
    print(arr, n);
    return 0;
}</pre>
          <h3>Visual representation</h3>
        <iframe width="560" height="315" src="https://www.youtube.com/embed/Tmq1UkL7xeU?si=ucNcEgQOq_TPejZM" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
        <p>Most of the information was taken from <a href="https://en.wikipedia.org/wiki/Radix_sort">here</a> and <a href="https://www.geeksforgeeks.org/radix-sort/">here</a>.</p>
      </section>
    </main>
  </body>
</html>